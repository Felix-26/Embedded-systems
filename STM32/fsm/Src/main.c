/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32f446xx.h"

#define TIM2EN 0
#define ARPE 7
#define UIE 0
#define UIF 0
#define PA5 5
#define CEN 0
#define UG 0
// SET PA0 AS ANALOG
#define PA0 0
#define PC13 13
// ADC_CR2
#define ADON 0
#define CONT 1
#define DMA 8
#define DDS 9
#define SWSTART 30
// ADC_SR
#define EOC 1
// RCC_APB2
#define ADC1EN 8

typedef enum {
	STATE_BLINK = 0,
	STATE_TEMP = 1
} state_t;

volatile state_t current_state = STATE_BLINK;

// if 0 blink else read temp
uint8_t blink_or_temp = 0;


void TIM2_IRQHandler()
{
	if(TIM2->SR & (1<<UIF))
	{
		TIM2->SR = 0;
		blink_or_temp = 1;
	}
}

void EXTI15_10_IRQHandler(void)
{
	if(EXTI->PR&(1<<PC13))
	{
		EXTI->PR |= (1<<PC13);
		if(current_state == STATE_BLINK)
			current_state = STATE_TEMP;
		else if(current_state == STATE_TEMP)
			current_state = STATE_BLINK;
	}
}


void timer2_init(void)
{
	RCC->APB1ENR |= (1<<TIM2EN);
	TIM2->PSC = 15;
	TIM2->ARR = 499999;
	TIM2->EGR |= (1<<UG);
	TIM2->CR1 |= (1<<ARPE | (1<<CEN));
	TIM2->DIER |= (1<<UIE);
	NVIC->ISER[0] |= (1<<28);
	NVIC->IPR[28] = (1<<4);
}


void led_en()
{
	GPIOA_CLK_EN();
	GPIOA->MODER &= ~(0x3<<(PA5*2));
	GPIOA->MODER |= (1<<(PA5*2));
	GPIOA->OTYPER &= ~(1<<PA5);
}

void toggle_led()
{
	GPIOA->ODR ^= (1<<PA5);
	blink_or_temp = 0;
}

void analog_LM35_init(void)
{
	// GPIOA PERIPHERAL CLOCK
	GPIOA_CLK_EN();
	// Analog mode
	GPIOA->MODER |= (0X3<<(PA0*2));
	// ADC clock
	RCC->APB2ENR |= (1<<ADC1EN);
	// channel sequence length L[3:0] = 0000 for 1 conversion
	ADC1->SQR1 = 0;
	// 1st conversion SQ1[4:0] = 0 for selecting channel 0
	ADC1->SQR3 = 0;

	// sampling rate = 480
	ADC1->SMPR2 |= (0X7<<0);
	// start ADC
	ADC1->CR2 |= (1<<ADON);
	// continuos conversion
	ADC1->CR2 |= (1<<CONT);
}

void temp_print()
{
	ADC1->CR2 |= (1<<SWSTART);
	// polling to check End of Conversion
	while(!(ADC1->SR & (1<<EOC)));
	// reading DR
	uint16_t dr = ADC1->DR;
	// temperature conversion
	float temp = ((dr*3.3) / 4095.0)*100.0;
	printf("T : %.3f%cC\n",temp,'Â°');
	blink_or_temp = 0;
}

void set_input(void)
{
	GPIOC_CLK_EN();
	// input mode
	GPIOC->MODER &= ~(0X3 << (PC13*2));
	// no pullup or pull down
	GPIOC->PUPDR &= ~(0X3 << (PC13*2));
	// enable syscfg clk
	RCC->APB2ENR |= (1<<14);
	// PC13 EXTERNAL INTERRUPT
	SYSCFG->EXTICR[3] &= ~(0xF<<4);
	SYSCFG->EXTICR[3] |= (0X2 << 4);
	// unmasking ONLY 13th interrupt line
	EXTI->IMR |= (1<<13);
	// ONLY 13TH LINE FOR Rising edge interrupt not falling edge
	EXTI->FTSR |= (1<<13);
	EXTI->RTSR &= ~(1<<13);

	NVIC->ISER[1] = (1<<(40-32));
	NVIC->IPR[40] = (1<<4);
}

void fsm(void)
{
	switch(current_state)
	{
		case STATE_BLINK :
							if(blink_or_temp){
								toggle_led();
								printf("STATE_BLINK\n");
							}
							break;
		case STATE_TEMP :
							if(blink_or_temp){
								temp_print();
								printf("STATE_TEMP\n");
							}
							break;
	}
}

int main(void)
{
	led_en();
	analog_LM35_init();
	timer2_init();
	set_input();
	for(;;)
		fsm();
}
